@"
import pandas as pd
import numpy as np
import joblib
import os
import xgboost as xgb

def update_model_with_new_entry(file_path, date_str, label, model_path="cme_classifier.pkl"):
    # === Step 1: Load derived features ===
    df = pd.read_excel(file_path, sheet_name="Derived_Metrics")
    features = {
        "peak_flux": df["peak_flux"].max(),
        "mean_flux": df["mean_flux"].mean(),
        "d_flux_dt": df["mean_flux"].diff().fillna(0).max(),
        "energy_integrated_flux": df["energy_integrated_flux"].sum(),
        "anisotropy_index": df["anisotropy_index"].mean(),
        "spectral_slope": df["spectral_slope"].mean()
    }

    # === Step 2: Handle missing slope ===
    if pd.isna(features["spectral_slope"]):
        features["spectral_slope"] = -0.681887  # fallback training mean

    features["label"] = label
    features["date"] = date_str

    # === Step 3: Load or initialize training database ===
    db_file = "cme_training_data.csv"
    if os.path.exists(db_file):
        data_df = pd.read_csv(db_file)
    else:
        data_df = pd.DataFrame()

    data_df = pd.concat([data_df, pd.DataFrame([features])], ignore_index=True)
    data_df.to_csv(db_file, index=False)

    # === Step 4: Train model ===
    X = data_df.drop(columns=["label", "date"])
    y = data_df["label"]

    # Check for class diversity
    unique_classes = sorted(y.unique())
    if len(unique_classes) < 2:
        print(f"⚠️ Cannot train model yet: only found label(s) {unique_classes}")
        return

    model = xgb.XGBClassifier(use_label_encoder=False, eval_metric="logloss")
    model.fit(X, y)
    joblib.dump(model, model_path)

    print("\\n✅ Model updated and saved as 'cme_classifier.pkl'")
    print(f"📦 Training entries: {len(y)}")
    print(f"📊 Label balance: {y.value_counts().to_dict()}")
"@ | Set-Content -Path "C:\Users\admins\Cme_Prediction_Pipeline.py"
